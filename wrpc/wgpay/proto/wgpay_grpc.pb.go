// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: proto/wgpay.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// WgpayClient is the client API for Wgpay service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WgpayClient interface {
	// Generate ticket
	GenCard(ctx context.Context, in *TradeNode, opts ...grpc.CallOption) (*No, error)
	GenTrade(ctx context.Context, in *TradeNode, opts ...grpc.CallOption) (*No, error)
	GenCombine(ctx context.Context, in *CombineNode, opts ...grpc.CallOption) (*No, error)
	GenRefund(ctx context.Context, in *RefundNode, opts ...grpc.CallOption) (*No, error)
	// Update amount
	ChangeTAmount(ctx context.Context, in *NoAment, opts ...grpc.CallOption) (*PEmpty, error)
	ChangeRAmount(ctx context.Context, in *NoAment, opts ...grpc.CallOption) (*PEmpty, error)
	// Revoke transaction
	RevokeTrade(ctx context.Context, in *No, opts ...grpc.CallOption) (*PEmpty, error)
	RevokeRefund(ctx context.Context, in *No, opts ...grpc.CallOption) (*PEmpty, error)
	// Update transaction
	UpdateTrade(ctx context.Context, in *UpTrade, opts ...grpc.CallOption) (*PEmpty, error)
	UpdateRefund(ctx context.Context, in *UpRefund, opts ...grpc.CallOption) (*PEmpty, error)
	// Get trade ticket
	TradeTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*TradeNode, error)
	CombineTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*CombineNode, error)
	DiviTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*DiviNode, error)
	RefundTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*RefundNode, error)
	// Pay method
	JSPay(ctx context.Context, in *TradeUID, opts ...grpc.CallOption) (*JSPayRet, error)
	CombineJS(ctx context.Context, in *TradeUID, opts ...grpc.CallOption) (*JSPayRet, error)
	QueryTrade(ctx context.Context, in *No, opts ...grpc.CallOption) (*QueryRet, error)
	TradeRefund(ctx context.Context, in *RefundNo, opts ...grpc.CallOption) (*RefundRet, error)
	AppPay(ctx context.Context, in *TradeNo, opts ...grpc.CallOption) (*AppPayRet, error)
	QueryRefund(ctx context.Context, in *No, opts ...grpc.CallOption) (*QueryRef, error)
}

type wgpayClient struct {
	cc grpc.ClientConnInterface
}

func NewWgpayClient(cc grpc.ClientConnInterface) WgpayClient {
	return &wgpayClient{cc}
}

func (c *wgpayClient) GenCard(ctx context.Context, in *TradeNode, opts ...grpc.CallOption) (*No, error) {
	out := new(No)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/GenCard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) GenTrade(ctx context.Context, in *TradeNode, opts ...grpc.CallOption) (*No, error) {
	out := new(No)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/GenTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) GenCombine(ctx context.Context, in *CombineNode, opts ...grpc.CallOption) (*No, error) {
	out := new(No)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/GenCombine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) GenRefund(ctx context.Context, in *RefundNode, opts ...grpc.CallOption) (*No, error) {
	out := new(No)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/GenRefund", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) ChangeTAmount(ctx context.Context, in *NoAment, opts ...grpc.CallOption) (*PEmpty, error) {
	out := new(PEmpty)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/ChangeTAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) ChangeRAmount(ctx context.Context, in *NoAment, opts ...grpc.CallOption) (*PEmpty, error) {
	out := new(PEmpty)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/ChangeRAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) RevokeTrade(ctx context.Context, in *No, opts ...grpc.CallOption) (*PEmpty, error) {
	out := new(PEmpty)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/RevokeTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) RevokeRefund(ctx context.Context, in *No, opts ...grpc.CallOption) (*PEmpty, error) {
	out := new(PEmpty)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/RevokeRefund", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) UpdateTrade(ctx context.Context, in *UpTrade, opts ...grpc.CallOption) (*PEmpty, error) {
	out := new(PEmpty)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/UpdateTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) UpdateRefund(ctx context.Context, in *UpRefund, opts ...grpc.CallOption) (*PEmpty, error) {
	out := new(PEmpty)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/UpdateRefund", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) TradeTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*TradeNode, error) {
	out := new(TradeNode)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/TradeTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) CombineTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*CombineNode, error) {
	out := new(CombineNode)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/CombineTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) DiviTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*DiviNode, error) {
	out := new(DiviNode)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/DiviTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) RefundTicket(ctx context.Context, in *No, opts ...grpc.CallOption) (*RefundNode, error) {
	out := new(RefundNode)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/RefundTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) JSPay(ctx context.Context, in *TradeUID, opts ...grpc.CallOption) (*JSPayRet, error) {
	out := new(JSPayRet)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/JSPay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) CombineJS(ctx context.Context, in *TradeUID, opts ...grpc.CallOption) (*JSPayRet, error) {
	out := new(JSPayRet)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/CombineJS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) QueryTrade(ctx context.Context, in *No, opts ...grpc.CallOption) (*QueryRet, error) {
	out := new(QueryRet)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/QueryTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) TradeRefund(ctx context.Context, in *RefundNo, opts ...grpc.CallOption) (*RefundRet, error) {
	out := new(RefundRet)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/TradeRefund", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) AppPay(ctx context.Context, in *TradeNo, opts ...grpc.CallOption) (*AppPayRet, error) {
	out := new(AppPayRet)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/AppPay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wgpayClient) QueryRefund(ctx context.Context, in *No, opts ...grpc.CallOption) (*QueryRef, error) {
	out := new(QueryRef)
	err := c.cc.Invoke(ctx, "/proto.Wgpay/QueryRefund", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WgpayServer is the server API for Wgpay service.
// All implementations must embed UnimplementedWgpayServer
// for forward compatibility
type WgpayServer interface {
	// Generate ticket
	GenCard(context.Context, *TradeNode) (*No, error)
	GenTrade(context.Context, *TradeNode) (*No, error)
	GenCombine(context.Context, *CombineNode) (*No, error)
	GenRefund(context.Context, *RefundNode) (*No, error)
	// Update amount
	ChangeTAmount(context.Context, *NoAment) (*PEmpty, error)
	ChangeRAmount(context.Context, *NoAment) (*PEmpty, error)
	// Revoke transaction
	RevokeTrade(context.Context, *No) (*PEmpty, error)
	RevokeRefund(context.Context, *No) (*PEmpty, error)
	// Update transaction
	UpdateTrade(context.Context, *UpTrade) (*PEmpty, error)
	UpdateRefund(context.Context, *UpRefund) (*PEmpty, error)
	// Get trade ticket
	TradeTicket(context.Context, *No) (*TradeNode, error)
	CombineTicket(context.Context, *No) (*CombineNode, error)
	DiviTicket(context.Context, *No) (*DiviNode, error)
	RefundTicket(context.Context, *No) (*RefundNode, error)
	// Pay method
	JSPay(context.Context, *TradeUID) (*JSPayRet, error)
	CombineJS(context.Context, *TradeUID) (*JSPayRet, error)
	QueryTrade(context.Context, *No) (*QueryRet, error)
	TradeRefund(context.Context, *RefundNo) (*RefundRet, error)
	AppPay(context.Context, *TradeNo) (*AppPayRet, error)
	QueryRefund(context.Context, *No) (*QueryRef, error)
	mustEmbedUnimplementedWgpayServer()
}

// UnimplementedWgpayServer must be embedded to have forward compatible implementations.
type UnimplementedWgpayServer struct {
}

func (UnimplementedWgpayServer) GenCard(context.Context, *TradeNode) (*No, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenCard not implemented")
}
func (UnimplementedWgpayServer) GenTrade(context.Context, *TradeNode) (*No, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenTrade not implemented")
}
func (UnimplementedWgpayServer) GenCombine(context.Context, *CombineNode) (*No, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenCombine not implemented")
}
func (UnimplementedWgpayServer) GenRefund(context.Context, *RefundNode) (*No, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenRefund not implemented")
}
func (UnimplementedWgpayServer) ChangeTAmount(context.Context, *NoAment) (*PEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeTAmount not implemented")
}
func (UnimplementedWgpayServer) ChangeRAmount(context.Context, *NoAment) (*PEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeRAmount not implemented")
}
func (UnimplementedWgpayServer) RevokeTrade(context.Context, *No) (*PEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeTrade not implemented")
}
func (UnimplementedWgpayServer) RevokeRefund(context.Context, *No) (*PEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeRefund not implemented")
}
func (UnimplementedWgpayServer) UpdateTrade(context.Context, *UpTrade) (*PEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTrade not implemented")
}
func (UnimplementedWgpayServer) UpdateRefund(context.Context, *UpRefund) (*PEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRefund not implemented")
}
func (UnimplementedWgpayServer) TradeTicket(context.Context, *No) (*TradeNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradeTicket not implemented")
}
func (UnimplementedWgpayServer) CombineTicket(context.Context, *No) (*CombineNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CombineTicket not implemented")
}
func (UnimplementedWgpayServer) DiviTicket(context.Context, *No) (*DiviNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiviTicket not implemented")
}
func (UnimplementedWgpayServer) RefundTicket(context.Context, *No) (*RefundNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefundTicket not implemented")
}
func (UnimplementedWgpayServer) JSPay(context.Context, *TradeUID) (*JSPayRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JSPay not implemented")
}
func (UnimplementedWgpayServer) CombineJS(context.Context, *TradeUID) (*JSPayRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CombineJS not implemented")
}
func (UnimplementedWgpayServer) QueryTrade(context.Context, *No) (*QueryRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTrade not implemented")
}
func (UnimplementedWgpayServer) TradeRefund(context.Context, *RefundNo) (*RefundRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradeRefund not implemented")
}
func (UnimplementedWgpayServer) AppPay(context.Context, *TradeNo) (*AppPayRet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppPay not implemented")
}
func (UnimplementedWgpayServer) QueryRefund(context.Context, *No) (*QueryRef, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRefund not implemented")
}
func (UnimplementedWgpayServer) mustEmbedUnimplementedWgpayServer() {}

// UnsafeWgpayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WgpayServer will
// result in compilation errors.
type UnsafeWgpayServer interface {
	mustEmbedUnimplementedWgpayServer()
}

func RegisterWgpayServer(s grpc.ServiceRegistrar, srv WgpayServer) {
	s.RegisterService(&Wgpay_ServiceDesc, srv)
}

func _Wgpay_GenCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).GenCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/GenCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).GenCard(ctx, req.(*TradeNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_GenTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).GenTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/GenTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).GenTrade(ctx, req.(*TradeNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_GenCombine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CombineNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).GenCombine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/GenCombine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).GenCombine(ctx, req.(*CombineNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_GenRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefundNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).GenRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/GenRefund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).GenRefund(ctx, req.(*RefundNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_ChangeTAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoAment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).ChangeTAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/ChangeTAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).ChangeTAmount(ctx, req.(*NoAment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_ChangeRAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoAment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).ChangeRAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/ChangeRAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).ChangeRAmount(ctx, req.(*NoAment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_RevokeTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).RevokeTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/RevokeTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).RevokeTrade(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_RevokeRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).RevokeRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/RevokeRefund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).RevokeRefund(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_UpdateTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpTrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).UpdateTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/UpdateTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).UpdateTrade(ctx, req.(*UpTrade))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_UpdateRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpRefund)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).UpdateRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/UpdateRefund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).UpdateRefund(ctx, req.(*UpRefund))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_TradeTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).TradeTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/TradeTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).TradeTicket(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_CombineTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).CombineTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/CombineTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).CombineTicket(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_DiviTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).DiviTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/DiviTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).DiviTicket(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_RefundTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).RefundTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/RefundTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).RefundTicket(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_JSPay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).JSPay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/JSPay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).JSPay(ctx, req.(*TradeUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_CombineJS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).CombineJS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/CombineJS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).CombineJS(ctx, req.(*TradeUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_QueryTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).QueryTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/QueryTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).QueryTrade(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_TradeRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefundNo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).TradeRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/TradeRefund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).TradeRefund(ctx, req.(*RefundNo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_AppPay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeNo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).AppPay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/AppPay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).AppPay(ctx, req.(*TradeNo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wgpay_QueryRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(No)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WgpayServer).QueryRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Wgpay/QueryRefund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WgpayServer).QueryRefund(ctx, req.(*No))
	}
	return interceptor(ctx, in, info, handler)
}

// Wgpay_ServiceDesc is the grpc.ServiceDesc for Wgpay service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Wgpay_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Wgpay",
	HandlerType: (*WgpayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenCard",
			Handler:    _Wgpay_GenCard_Handler,
		},
		{
			MethodName: "GenTrade",
			Handler:    _Wgpay_GenTrade_Handler,
		},
		{
			MethodName: "GenCombine",
			Handler:    _Wgpay_GenCombine_Handler,
		},
		{
			MethodName: "GenRefund",
			Handler:    _Wgpay_GenRefund_Handler,
		},
		{
			MethodName: "ChangeTAmount",
			Handler:    _Wgpay_ChangeTAmount_Handler,
		},
		{
			MethodName: "ChangeRAmount",
			Handler:    _Wgpay_ChangeRAmount_Handler,
		},
		{
			MethodName: "RevokeTrade",
			Handler:    _Wgpay_RevokeTrade_Handler,
		},
		{
			MethodName: "RevokeRefund",
			Handler:    _Wgpay_RevokeRefund_Handler,
		},
		{
			MethodName: "UpdateTrade",
			Handler:    _Wgpay_UpdateTrade_Handler,
		},
		{
			MethodName: "UpdateRefund",
			Handler:    _Wgpay_UpdateRefund_Handler,
		},
		{
			MethodName: "TradeTicket",
			Handler:    _Wgpay_TradeTicket_Handler,
		},
		{
			MethodName: "CombineTicket",
			Handler:    _Wgpay_CombineTicket_Handler,
		},
		{
			MethodName: "DiviTicket",
			Handler:    _Wgpay_DiviTicket_Handler,
		},
		{
			MethodName: "RefundTicket",
			Handler:    _Wgpay_RefundTicket_Handler,
		},
		{
			MethodName: "JSPay",
			Handler:    _Wgpay_JSPay_Handler,
		},
		{
			MethodName: "CombineJS",
			Handler:    _Wgpay_CombineJS_Handler,
		},
		{
			MethodName: "QueryTrade",
			Handler:    _Wgpay_QueryTrade_Handler,
		},
		{
			MethodName: "TradeRefund",
			Handler:    _Wgpay_TradeRefund_Handler,
		},
		{
			MethodName: "AppPay",
			Handler:    _Wgpay_AppPay_Handler,
		},
		{
			MethodName: "QueryRefund",
			Handler:    _Wgpay_QueryRefund_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/wgpay.proto",
}
